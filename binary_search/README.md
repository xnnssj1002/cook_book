## 二分搜索
### 二分搜索的经典写法。需要注意的三点：
1. 循环退出条件，注意是 low <= high，而不是 low < high。
2. mid 的取值，mid := low + (high-low)>>1
3. low 和 high 的更新，low = mid + 1，high = mid - 1。

### 二分搜索的变种写法。有 4 个基本变种:
1. 查找第一个与 target 相等的元素，时间复杂度 O(logn)
2. 查找最后一个与 target 相等的元素，时间复杂度 O(logn)
3. 查找第一个大于等于 target 的元素，时间复杂度 O(logn)
4. 查找最后一个小于等于 target 的元素，时间复杂度 O(logn)

代码见traditional_binary文件

### 二分搜索需要考虑的细节
1. 区间的开闭问题：区间应该是左闭右闭区间 [left, right]，还是左闭右开区间 [left, right)？
2. mid 的取值问题：mid = left+(right-left)/2，还是 mid = left+(right-left+1)/2？
3. 循环退出条件(出界条件)的判断：left ≤ right，还是 left < right？
4. 搜索区间范围的选择：left = mid + 1、right = mid - 1、left = mid、right = mid 应该怎么写？

### 一、区间的开闭问题
左闭右闭区间、左闭右开区间指的是：初始待查找区间的范围。

左闭右闭区间：
* 初始化时，left = 0，right = len(nums) - 1
* left 为数组第一个元素位置，right 为数组最后一个元素位置。
* 区间 [left, right] 左右边界上的点都能取到

左闭右开区间：
* 初始化时，left = 0，right = len(nums)
* left 为数组第一个元素位置，right 为数组最后一个元素的下一个位置
* 区间 [left, right) 左边界点能取到，而右边界上的点不能取到

结论： 关于二分查找算法的左闭右闭区间、左闭右开区间，其实在网上都有对应的代码。但是相对来说，左闭右开区间这种写法在解决问题的过程中，会使得问题变得复杂，需要考虑的情况更多，所以不建议使用左闭右开区间这种写法，而是建议：全部使用「左闭右闭区间」这种写法。

### 二、mid 的取值问题
在二分查找的实际问题中，最常见的 mid 取值公式有两个：
* mid = left + (right-left)/2
* mid = left + (right-left+1)/2

当待查找区间中的元素个数为奇数时，使用这两种取值公式取到的都是中间元素的下标位置，如下图：\
![img.png](odd_mid.png)

当待查找区间中的元素个数为偶数时，使用 mid = left + (right-left)/2 取到的是中间靠左边元素的下标位置；使用 mid = left + (right-left+1)/2 取到的是中间靠右边元素的下标位置，如下图：\
![img.png](even_mid.png)

那在程序中到底选择哪个公式来计算中间值呢？\
因为二分查找算法的思路是：根据每次选择中间位置上的数值来决定下一次在哪个区间查找元素。\
每一次选择的元素位置可以是中间位置，但并不是一定非得是区间中间位置元素，靠左一些、靠右一些、甚至区间三分之一、五分之一处等等，都是可以的。\
唯一不同的是下次待查找区间范围的大小问题，下一次的待查找区间可能会大一些，也可能会小一些。\
但通常来说，取区间中间位置在平均意义下所达到的效果最好，同时这样写最简单。 而对于这两个取值公式，大多数时候是选择第一个公式。\
不过，有些情况下，是需要考虑第二个公式的，在下边使用「排除法」实现二分查找中进行说明。

此外，除了上面提到的这两种写法，我们还经常能看到下面两个公式：
* mid = (left + right)/2
* mid = (left + right + 1)/2

这两个公式其实分别等同于之前两个公式，可以看做是之前两个公式的另一种写法。但是这里的两个公式存在弊端。在有类型大小限制的语言中，会出现整型溢出的危险。
因为这两个公式使用了(left + right)，如果(left + right)相加之后超过了整型可以表示的范围，就是整型溢出。
在(left+right)的数据量不会超过整型变量最大值时，这两种写法都没有问题。在(left + right)的数据量可能会超过整型变量最大值时，最好使用第一种写法。

### 三、循环退出条件(出界条件)的判断
二分查找算法的写法中，for循环语句的退出条件通常有两种：
1. left <= right
2. left < right

实际编码中应该使用哪一种写法呢？要回答这个问题，我们先来判断一下导致for循环语句退出的条件是什么。
1. 如果判断语句为 left <= right，并且要查找的元素不在有序数组中，则 for 语句的出界条件一定是 left > right，也就是 left == right + 1，写成区间的形式就是 [right + 1, right]，很明显此区间为空，待查找区间中没有元素存在，此时终止循环时，可以直接返回 −1。
   * 比如说区间 [3, 2]， 此时左边界大于右边界，直接终止循环，返回 −1 即可。
2. 如果判断语句为 left < right，并且查找的元素不在有序数组中，则 for 语句出界条件是 left == right，写成区间的形式就是 [right, right]。很明显此时区间不为空，待查找区间还有一个元素存在，我们不能贸然地判断待查找的元素不在该数组中，然后返回-1。我们还需要在退出循环之后，判断最后一个元素是否与待查找元素相等，然后进行返回。
    * 比如说区间 [2, 2]，如果元素 ]nums[2] 刚好就是目标元素 target，此时终止循环，返回 −1 就漏掉了这个元素。
    * 但是使用用 left < right 有一个好处，就是在跳出循环的时候，一定是 left == right，我们就不用判断此时应该返回 left 还是 right 了。

### 四、下一次搜索区间范围的选择
在进行区间范围选择的时候，通常有三种写法：
1. left = mid + 1，right = mid - 1
2. left = mid + 1 ，right = mid
3. left = mid，right = mid - 1
我们到底应该如何确定下一次搜索区间的范围呢？\
这是二分查找的一个难点，写错了很容易造成死循环，或者得不到正确结果。\
这其实跟二分查找算法的两种不同思路和三种写法有关。\
* 思路 1：「直接法」—— 在循环体中找到元素后直接返回结果。
* 思路 2：「排除法」—— 在循环体中排除目标元素一定不存在区间。

接下来我们具体讲解下这两种思路。

### 五、二分查找的思路
#### 5-1、直接法
> 直接法思想：在循环体中找到元素就直接返回结果。

思路：
1. 设定左右边界为数组两端，即 left = 0，right = len(nums) - 1，代表待查找区间为 [left, right]（左闭右闭区间）。
2. 取两个节点中心位置 mid，先比较中心位置值 nums[mid] 与目标值 target 的大小。 
   * 如果 target == nums[mid]，则直接返回中心位置。
   * 如果 target > nums[mid]，则将左节点设置为 mid + 1，然后继续在右区间 [mid + 1, right] 搜索。
   * 如果 target < nums[mid]，则将右节点设置为 mid - 1，然后继续在左区间 [left, mid - 1] 搜索。
3. 如果左边界大于右边界，查找范围缩小为空，说明目标元素不存在，此时返回 −1-1−1。

代码：
``` go
func search(nums []int, target int) int {
   low, high := 0, len(nums)-1
    for low <= high {
        mid := low + (high-low+1)>>1
        // mid := low + (high-low)>>1
        if nums[mid] == target {
            return mid
        }
        
        if nums[mid] > target {
            high = mid -1
            
        } else {
            low = mid + 1
        }
    }
    return -1
}
```

细节：
1. 这种思路是在一旦循环体中找到元素就直接返回。
2. 循环可以继续的条件是 left <= right。
3. 如果一旦退出循环，则说明这个区间内一定不存在目标元素。

#### 5-2、排除法
> 排除法思想：在循环体中排除目标元素一定不存在区间。

思路：
1. 设定左右边界为数组两端，即 left = 0，right = len(nums) - 1，代表待查找区间为[left, right]（左闭右闭区间）。
2. 取两个节点中心位置 mid，比较目标元素和中间元素的大小，先将目标元素一定不存在的区间排除。
3. 然后在剩余区间继续查找元素，继续根据条件排除目标元素一定不存在的区间。
4. 直到区间中只剩下最后一个元素，然后再判断这个元素是否是目标元素。

代码1：(high=mid) \
下次求中间值时，需要取左边的数(针对数组个数为偶数时)，即：
mid := low + (high-low)>>1
``` go
func search(nums []int, target int) int {
   low, high := 0, len(nums)-1
   
   for low < high {
      mid := low + (high-low)>>1
      // mid := low + (high-low+1)>>1 这里这样写会死循环
      if target > nums[mid] {
         low = mid + 1
         
      } else {
         high = mid
      }
   }
   
   if nums[low] == target {
      return low
   } else {
      return -1
   }
}
```

代码2：(low=mid) \
下次求中间值时，需要取右边的数(针对数组个数为偶数时)，即：\
mid := low + (high-low+1)>>1
``` go
func search(nums []int, target int) int {
   low, high := 0, len(nums)-1
    for low < high {
        mid := low + (high-low+1)>>1
        // mid := low + (high-low)>>1 这里这样写会死循环
        if target < nums[mid] {
            high = mid - 1
            
        } else {
            low = mid
        }
    }

    if nums[low] == target {
        return low
    } else {
        return -1
    }
}
```

细节：
1. 判断语句是 left < right。这样在退出循环时，一定有left == right 成立，就不用判断应该返回 left 还是 right 了。此时只需要判断 nums[left] 是否为目标元素即可。
2. 在循环体中，比较目标元素和中间元素的大小之后，优先将目标元素一定不存在的区间排除，然后再从剩余区间中确定下一次查找区间的范围。
3. 在将目标元素一定不存在的区间排除之后，它的对立面一般就不需要再考虑区间范围了，直接取上一个区间的相反区间。
   * 如果上一个区间是 [mid + 1, right]，那么相反区间就是[left, mid]。
   * 如果上一个区间是 [left, mid - 1]，那么相反区间就是 [mid, right]。
4. 为了避免陷入死循环，当区间被划分为 [left, mid - 1] 与 [mid, right] 两部分时，即left=mid时，mid需要取右边的数(针对数组个数为偶数时)。即 mid = left + (right - left + 1)/2。 否则就会陷入死循环，因为如果当区间中只剩下两个元素时，一旦进入 left = mid 分支，区间就不会再缩小了，下一次循环的查找区间还是 [left, right]，就陷入了死循环。
   * 比如左边界 left = 5，右边界 right = 6，此时查找区间为 [5, 6]，mid = 5 + (6 - 5)/2 = 5，如果进入 left = mid 分支，那么下次查找区间仍为 [5, 6]，区间不再缩小，陷入死循环。
   * 这种情况下，mid 应该向上取整，mid = 5 + (6 - 5 + 1)/2 = 6，如果进入 left = mid 分支，则下次查找区间为 [6, 6]。

### 六、两种思路适用范围
* 直接法：因为判断语句是 left <= right，有时候要考虑返回是 left 还是 right。循环体内有 3 个分支，并且一定有一个分支用于退出循环或者直接返回。这种思路适合解决简单题目。即要查找的元素性质简单，数组中都是非重复元素，且 ==、>、< 的情况非常好写的时候。
* 排除法：更加符合二分查找算法的减治思想。每次排除目标元素一定不存在的区间，达到减少问题规模的效果。然后在可能存在的区间内继续查找目标元素。这种思路适合解决复杂题目。比如查找一个数组里可能不存在的元素，找边界问题，可以使用这种思路。



